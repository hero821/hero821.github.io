<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>修改Proxifier配置文件存储路径</title>
    <url>/2020/10/01/%E4%BF%AE%E6%94%B9Proxifier%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>今天使用Proxifier的时候，发现配置文件存储路径为：C:\Users\<User>\AppData\Roaming\Proxifier\Profiles。<br>这样就会存在一些风险，例如：重装系统的时候（格式化系统盘），如果没想起来备份，可能就再也找不到了。<br>风险既然发现，就要想办法规避。</p>
<span id="more"></span>

<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>首先，查看Proxifier帮助文档（路径：D:\Program Files (x86)\Proxifier\Proxifier.chm），无果。</li>
<li>然后，Google查资料，无果。</li>
<li>然后，试了试在C:\Users\<User>\AppData\Roaming\Proxifier下面创建Profiles快捷方式，删除Profiles文件夹，结果启动Proxifier之后，竟然又自动生成了Profiles文件夹，失败。</li>
<li>最后，我想起来Linux有个ln命令，效果是我想要的，开始Google查询“windows 软连接”，找到了mklink命令。</li>
</ul>
<p>查看help：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mklink</span><br><span class="line">创建符号链接。</span><br><span class="line"></span><br><span class="line">MKLINK [[/D] | [/H] | [/J]] Link Target</span><br><span class="line"></span><br><span class="line">        /D      创建目录符号链接。默认为文件</span><br><span class="line">                符号链接。</span><br><span class="line">        /H      创建硬链接而非符号链接。</span><br><span class="line">        /J      创建目录联接。</span><br><span class="line">        Link    指定新的符号链接名称。</span><br><span class="line">        Target  指定新链接引用的路径</span><br><span class="line">                (相对或绝对)。</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>注：需要管理员权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mklink /D C:\Users\&lt;User&gt;\AppData\Roaming\Proxifier\Profiles E:\Config\Proxifier\Profiles</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Proxifier</tag>
      </tags>
  </entry>
  <entry>
    <title>升级jar包中单文件</title>
    <url>/2020/10/01/%E5%8D%87%E7%BA%A7jar%E5%8C%85%E4%B8%AD%E5%8D%95%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>开发springboot项目的时候，我们经常会以jar包的形式进行部署。这个时候，如果需要修改某一个文件，那么该怎么升级呢？</p>
<ul>
<li>本地重新打包，全包上传到服务器</li>
<li>只上传单文件到服务器，在服务器上把单文件合并到原来的jar包中</li>
</ul>
<p>显然，第一种方案在网速较慢的时候，是影响工作效率的。</p>
<span id="more"></span>

<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>查看help：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[security@localhost jars]$ jar</span><br><span class="line">用法: jar &#123;ctxui&#125;[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] files ...</span><br><span class="line">选项包括: </span><br><span class="line">    -c  创建新的归档文件</span><br><span class="line">    -t  列出归档目录</span><br><span class="line">    -x  从档案中提取指定的 (或所有) 文件</span><br><span class="line">    -u  更新现有的归档文件</span><br><span class="line">    -v  在标准输出中生成详细输出</span><br><span class="line">    -f  指定归档文件名</span><br><span class="line">    -m  包含指定清单文件中的清单信息</span><br><span class="line">    -e  为捆绑到可执行 jar 文件的独立应用程序</span><br><span class="line">        指定应用程序入口点</span><br><span class="line">    -0  仅存储; 不使用情况任何 ZIP 压缩</span><br><span class="line">    -M  不创建条目的清单文件</span><br><span class="line">    -i  为指定的 jar 文件生成索引信息</span><br><span class="line">    -C  更改为指定的目录并包含其中的文件</span><br><span class="line">如果有任何目录文件, 则对其进行递归处理。</span><br><span class="line">清单文件名, 归档文件名和入口点名称的指定顺序</span><br><span class="line">与 &#x27;m&#x27;, &#x27;f&#x27; 和 &#x27;e&#x27; 标记的指定顺序相同。</span><br><span class="line"></span><br><span class="line">示例 1: 将两个类文件归档到一个名为 classes.jar 的归档文件中: </span><br><span class="line">       jar cvf classes.jar Foo.class Bar.class </span><br><span class="line">示例 2: 使用现有的清单文件 &#x27;mymanifest&#x27; 并</span><br><span class="line">           将 foo/ 目录中的所有文件归档到 &#x27;classes.jar&#x27; 中: </span><br><span class="line">       jar cvfm classes.jar mymanifest -C foo/ .</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>查看文件在jar包中的路径</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[security@localhost jars]$ jar tvf service.jar |grep todo</span><br><span class="line">  304 Fri Aug 23 12:00:00 CST 2019 BOOT-INF/classes/templates/todo.ftl</span><br></pre></td></tr></table></figure>

<ul>
<li>解压出文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[security@localhost jars]$ jar xvf service.jar BOOT-INF/classes/templates/todo.ftl</span><br><span class="line">  已解压: BOOT-INF/classes/templates/todo.ftl</span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖解压出的文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv todo.ftl BOOT-INF/classes/templates/todo.ftl</span><br></pre></td></tr></table></figure>

<ul>
<li>合并文件到jar包中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[security@localhost jars]$ jar uvf service.jar BOOT-INF/classes/templates/todo.ftl</span><br><span class="line">  正在添加: BOOT-INF/classes/templates/todo.ftl(输入 = 304) (输出 = 195)(压缩了 35%)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除解压出的文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[security@localhost jars]$ rm -rf BOOT-INF</span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>安装WireGuard</title>
    <url>/2021/07/20/%E5%AE%89%E8%A3%85WireGuard/</url>
    <content><![CDATA[<h1 id="安装windows端"><a href="#安装windows端" class="headerlink" title="安装windows端"></a>安装windows端</h1><p>安装wireguard-amd64-0.3.16.msi：可以正常安装，无法正常使用<br>安装TunSafe-1.4.exe：可以正常安装，可以正常使用，可以支持ListenPortTCP</p>
<h1 id="安装centos端"><a href="#安装centos端" class="headerlink" title="安装centos端"></a>安装centos端</h1><blockquote>
<p>需要升级内核</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release elrepo-release</span><br><span class="line">yum install yum-plugin-elrepo</span><br><span class="line">yum install kmod-wireguard wireguard-tools</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">reboot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载内核模块</span></span><br><span class="line">modprobe wireguard</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查WG模块加载是否正常</span></span><br><span class="line">lsmod | grep wireguard</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="安装wireguard-go端"><a href="#安装wireguard-go端" class="headerlink" title="安装wireguard-go端"></a>安装wireguard-go端</h1><blockquote>
<p>无需升级内核，多平台，性能差</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/go/src/github.com</span><br><span class="line">cd ~/go/src/github.com</span><br><span class="line">git clone https://github.com/WireGuard/wireguard-go.git</span><br><span class="line">cd wireguard-go</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">yum install wireguard-tools</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> WG_QUICK_USERSPACE_IMPLEMENTATION=wireguard-go</span></span><br><span class="line">wg-quick up wg0</span><br></pre></td></tr></table></figure>

<h1 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wg genkey &gt; privatekey</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wg pubkey &lt; privatekey &gt; publickey</span></span><br><span class="line">wg genkey | tee privatekey | wg pubkey &gt; publickey</span><br><span class="line">vi /etc/wireguard/wg0.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">[Interface]</span><br><span class="line">Address = 10.0.0.1/24</span><br><span class="line">ListenPort = 51820</span><br><span class="line">PrivateKey = &lt;Server Private Key&gt;</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">systemctl enable wg-quick@wg0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务端</span></span><br><span class="line">wg-quick up wg0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务端</span></span><br><span class="line">wg-quick down wg0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点列表</span></span><br><span class="line">wg show</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载配置文件，不影响已有连接</span></span><br><span class="line">wg syncconf wg0 &lt;(wg-quick strip wg0)</span><br></pre></td></tr></table></figure>

<h1 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wg genkey | tee privatekey | wg pubkey &gt; publickey</span><br><span class="line">vi /etc/wireguard/wg0.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">[Interface]</span><br><span class="line">Address = 10.0.0.2/24</span><br><span class="line">ListenPort = 51820</span><br><span class="line">PrivateKey = &lt;Client Private Key&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure>

<h1 id="连接-Client-和-Server"><a href="#连接-Client-和-Server" class="headerlink" title="连接 Client 和 Server"></a>连接 Client 和 Server</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>服务端wg0.conf添加到客户端Peer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;Client Public key&gt;</span><br><span class="line">AllowedIPs = 10.0.0.2/32</span><br><span class="line">PersistentKeepalive = 30</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure>

<p>客户端wg0.conf添加到服务端Peer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;Server Public Key&gt;</span><br><span class="line">AllowedIPs = 10.0.0.0/24</span><br><span class="line">Endpoint = &lt;Server Public IP&gt;:51820</span><br><span class="line">PersistentKeepalive = 30</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure>

<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>服务端执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wg set wg0 peer &lt;Client Public key&gt; allowed-ips 10.0.0.2/32 persistent-keepalive 30</span><br><span class="line">wg-quick save wg0</span><br></pre></td></tr></table></figure>

<p>客户端执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wg set wg0 peer &lt;Server Public Key&gt; allowed-ips 10.0.0.0/24 persistent-keepalive 30 endpoint &lt;Server Public IP&gt;:51820 </span><br><span class="line">wg-quick save wg0</span><br></pre></td></tr></table></figure>

<h1 id="配置生成"><a href="#配置生成" class="headerlink" title="配置生成"></a>配置生成</h1><p><a href="https://www.wireguardconfig.com/">https://www.wireguardconfig.com</a></p>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>WireGuard</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>安装redsocks</title>
    <url>/2021/07/21/%E5%AE%89%E8%A3%85redsocks/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libevent-devel git gcc</span><br><span class="line">git clone https://github.com/darkk/redsocks</span><br><span class="line">cd redsocks</span><br><span class="line">make</span><br><span class="line">cp redsocks /usr/bin</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置redsocks"><a href="#配置redsocks" class="headerlink" title="配置redsocks"></a>配置redsocks</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/redsocks</span><br><span class="line">cp redsocks.conf.example /etc/redsocks/redsocks.conf</span><br><span class="line">cd /etc/redsocks</span><br><span class="line">vi redsocks.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">base &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">daemon = on;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">&#125;</span><br><span class="line">redsocks &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">ip = 127.0.0.1;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure>

<h2 id="配置iptables"><a href="#配置iptables" class="headerlink" title="配置iptables"></a>配置iptables</h2><p>仅192.168.0.0/24走代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建链</span></span><br><span class="line">iptables -t nat -N REDSOCKS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用REDSOCKS</span></span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j REDSOCKS</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j REDSOCKS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅192.168.0.0/24走代理</span></span><br><span class="line">iptables -t nat -A REDSOCKS -p tcp -d 192.168.0.0/24 -j REDIRECT --to-ports 12345</span><br><span class="line">iptables -t nat -A REDSOCKS -p tcp -j RETURN</span><br></pre></td></tr></table></figure>

<p>仅192.168.0.0/24不走代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建链</span></span><br><span class="line">iptables -t nat -N REDSOCKS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用REDSOCKS</span></span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j REDSOCKS</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j REDSOCKS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅192.168.0.0/24不走代理</span></span><br><span class="line">iptables -t nat -A REDSOCKS -d 192.168.0.0/24 -j RETURN</span><br><span class="line">iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br></pre></td></tr></table></figure>

<p>指定用户建立的连接走代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner luser -j REDSOCKS</span><br><span class="line">firefox</span><br></pre></td></tr></table></figure>

<p>指定组建立的连接走代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd socksified</span><br><span class="line">usermod --append --groups socksified luser</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -m owner --gid-owner socksified -j REDSOCKS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以特定的组执行命令，结合上面命令使用</span></span><br><span class="line">id</span><br><span class="line">uid=1000(luser) gid=1000(luser) groups=1000(luser),1001(socksified)</span><br><span class="line">sg socksified -c id</span><br><span class="line">uid=1000(luser) gid=1001(socksified) groups=1000(luser),1001(socksified)</span><br><span class="line">sg socksified -c firefox</span><br></pre></td></tr></table></figure>

<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redsocks -v</span><br><span class="line">redsocks -c /etc/redsocks/redsocks.conf</span><br></pre></td></tr></table></figure>

<h2 id="自动启动"><a href="#自动启动" class="headerlink" title="自动启动"></a>自动启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/redsocks.service</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">[Unit]</span><br><span class="line">Description=redsocks</span><br><span class="line">After=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/bin/redsocks -c /etc/redsocks/redsocks.conf</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">systemctl enable redsocks &amp;&amp; systemctl start redsocks &amp;&amp; systemctl status redsocks</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>redsocks</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>安装sshuttle</title>
    <url>/2021/07/21/%E5%AE%89%E8%A3%85sshuttle/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>支持TCP、UDP，不支持ICMP</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export &#123;http,https,ftp&#125;_proxy=&quot;http://127.0.0.1:1081&quot;</span><br><span class="line">yum install python3 python3-devel gcc</span><br></pre></td></tr></table></figure>

<h2 id="主机环境安装"><a href="#主机环境安装" class="headerlink" title="主机环境安装"></a>主机环境安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install sshuttle</span><br></pre></td></tr></table></figure>

<h2 id="虚拟环境安装"><a href="#虚拟环境安装" class="headerlink" title="虚拟环境安装"></a>虚拟环境安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install virtualenv</span><br><span class="line">virtualenv -p python3 /tmp/sshuttle</span><br><span class="line">source /tmp/sshuttle/bin/activate</span><br><span class="line">python -V &amp;&amp; pip -V</span><br><span class="line">pip install sshuttle</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="代理TCP"><a href="#代理TCP" class="headerlink" title="代理TCP"></a>代理TCP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sshuttle -r root@127.0.0.1:60022 0.0.0.0/0 -x 192.168.128.0/24 -v</span><br></pre></td></tr></table></figure>

<h2 id="代理TCP和DNS"><a href="#代理TCP和DNS" class="headerlink" title="代理TCP和DNS"></a>代理TCP和DNS</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sshuttle -r root@127.0.0.1:60022 0.0.0.0/0 -x 192.168.128.0/24 --dns -v</span><br></pre></td></tr></table></figure>

<h2 id="代理TCP和UDP"><a href="#代理TCP和UDP" class="headerlink" title="代理TCP和UDP"></a>代理TCP和UDP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sshuttle -r root@127.0.0.1:60022 0.0.0.0/0 -x 192.168.128.0/24 --method tproxy -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加路由</span></span><br><span class="line">ip route add local default dev lo table 100</span><br><span class="line">ip rule add fwmark 1 lookup 100</span><br><span class="line">ip -6 route add local default dev lo table 100</span><br><span class="line">ip -6 rule add fwmark 1 lookup 100</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>sshuttle</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Docker容器的访问策略</title>
    <url>/2021/07/21/%E9%85%8D%E7%BD%AEDocker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>需要对容器暴露的主机端口进行白名单访问控制，仅允许某些IP访问主机端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 60080:80 nginx:1.20-alpine</span><br></pre></td></tr></table></figure>

<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>Docker通过操作iptables规则来提供网络隔离。<br>Docker安装了两个名为DOCKER-USER和DOCKER的自定义iptables链，并确保传入的数据包始终首先由这两个链检查。<br>Docker的所有iptables规则都添加到DOCKER链中，不要手动修改此链。<br>如果需要添加自定义规则，请使用DOCKER-USER链，DOCKER-USER链在Docker链之前应用，也就是说用户自定义规则优先于Docker规则。<br>DOCKER-USER链默认只有一条规则，意思是 允许所有流量通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>不推荐直接在FORWARD链中添加规则，具体原因，分两种情况说明</p>
<ol>
<li>在FORWARD链底部添加规则<br>由于Docker自动添加的ACCEPT规则在前面，所以自定义规则无法起作用。</li>
<li>在FORWARD链顶部添加规则<br>刚添加完规则的时候是起作用的。<br>执行systemctl restart docker等操作之后，Docker会把自己的规则添加到FORWARD链顶部，导致自定义规则无法起作用。</li>
</ol>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>允许IP访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I DOCKER-USER -i eth0 ! -s 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure>

<p>允许网段访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I DOCKER-USER -i eth0 ! -s 192.168.1.0/24 -j DROP</span><br></pre></td></tr></table></figure>

<p>允许连续IP访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I DOCKER-USER -m iprange -i eth0 ! --src-range 192.168.1.1-192.168.1.3 -j DROP</span><br></pre></td></tr></table></figure>

<p>允许多IP访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I DOCKER-USER -i eth0 -j DROP</span><br><span class="line">iptables -I DOCKER-USER -i eth0 -p tcp -m tcp -s 192.168.1.0/24 --dport 60080 -j RETURN</span><br><span class="line">iptables -I DOCKER-USER -i eth0 -p tcp -m tcp -s 192.168.2.0/24 --dport 60080 -j RETURN</span><br><span class="line">iptables -nvL</span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 RETURN     tcp  --  eth0   *       192.168.2.0/24       0.0.0.0/0            tcp dpt:60080</span><br><span class="line">    0     0 RETURN     tcp  --  eth0   *       192.168.1.0/24       0.0.0.0/0            tcp dpt:60080</span><br><span class="line">    0     0 DROP       all  --  eth0   *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>iptables</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
